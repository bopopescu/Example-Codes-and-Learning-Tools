/*==============================================================
 *
 * MATRIXDRIVER.CPP
 * Sample driver code that calls a C++ shared library created using
 * the MATLAB Compiler. Refer to the MATLAB Compiler documentation
 * for more information on this
 *
 * This is the wrapper CPP code to call a shared library created 
 * using the MATLAB Compiler.
 *
 * Copyright 1984-2005 The MathWorks, Inc.
 *
 *============================================================*/

#ifdef __APPLE_CC__
#include <CoreFoundation/CoreFoundation.h>
#endif

// Include the library specific header file as generated by the 
// MATLAB Compiler
#include "libmatrixp.h"

void *run_main(void *x)
{
    int *err = (int *)x;
    if (err == NULL) return 0;

    // Call application and library initialization. Perform this 
    // initialization before calling any API functions or
    // Compiler-generated libraries.
    if (!mclInitializeApplication(NULL,0)) 
    {
        std::cerr << "could not initialize the application properly"
                   << std::endl;
	*err = -1;
        return x;
    }
    if( !libmatrixpInitialize() )
    {
        std::cerr << "could not initialize the library properly"
                   << std::endl;
	*err = -1;
    }
    else
    {
        try
        {
            // Create input data
            double data[] = {1,2,3,4,5,6,7,8,9};
            mwArray in1(3, 3, mxDOUBLE_CLASS, mxREAL);
            mwArray in2(3, 3, mxDOUBLE_CLASS, mxREAL);
            in1.SetData(data, 9);
            in2.SetData(data, 9);
            
            // Create output array
            mwArray out;
            
            // Call the library function
            addmatrix(1, out, in1, in2);
            
            // Display the return value of the library function
            std::cout << "The value of added matrix is:" << std::endl;
            std::cout << out << std::endl;
            
            multiplymatrix(1, out, in1, in2);
            std::cout << "The value of the multiplied matrix is:" 
                      << std::endl;
            std::cout << out << std::endl;
            
            eigmatrix(1, out, in1);
            std::cout << "The eigenvalues of the first matrix are:"
                      << std::endl;
            std::cout << out << std::endl;
        }
        catch (const mwException& e)
        {
          std::cerr << e.what() << std::endl;
          *err = -2;
        }
        catch (...)
        {
          std::cerr << "Unexpected error thrown" << std::endl;
          *err = -3;
        }     
        // Call the application and library termination routine
        libmatrixpTerminate();
    }
/* On MAC, you need to call mclSetExitCode with the appropriate exit status
 * Also, note that you should call mclTerminate application in the end of
 * your application. mclTerminateApplication terminates the entire 
 * application and exits with the exit code set using mclSetExitCode. Note
 * that this behavior is only on MAC platform.
 */
#ifdef __APPLE_CC__
    mclSetExitCode(*err);
#endif
    mclTerminateApplication();
    return 0;
}

int main()
{
    int err = 0;
#ifdef __APPLE_CC__
    pthread_t id;
    pthread_create(&id, NULL, run_main, &err);

    CFRunLoopSourceContext sourceContext;
    sourceContext.version         = 0;
    sourceContext.info            = NULL;
    sourceContext.retain          = NULL;
    sourceContext.release         = NULL;
    sourceContext.copyDescription = NULL;
    sourceContext.equal           = NULL;
    sourceContext.hash            = NULL;
    sourceContext.schedule        = NULL;
    sourceContext.cancel          = NULL;
    sourceContext.perform         = NULL;

    CFRunLoopSourceRef sourceRef = CFRunLoopSourceCreate(NULL, 0, &sourceContext);
    CFRunLoopAddSource(CFRunLoopGetCurrent(), sourceRef, kCFRunLoopCommonModes);
    CFRunLoopRun();
#else
    run_main(&err);
#endif
    return err;
}
