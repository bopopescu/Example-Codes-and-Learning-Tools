// µ{¦¡¦WºÙ: oop_DATE.cpp
// µ{¦¡¥\¯à: ©w¸q¤@­ÓDateÃş§O¡A¨Ï¥Î¦UºØ¹Bºâ¤lÂĞ¸ü

#include "oop_Date.h"

char Date::charBuf[Date::BUF_SIZE];

const char *dayname[] = {"Sunday","Monday","Tuesday","Wednesday",
	   "Thursday","Friday","Saturday"} ;

const char *mname[] = {"January","February","March","April","May",
	   "June","July","August","September","October","November","December"};

static int GauDays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

////////////////////////////////////////////////////////////
// Constructors
////////////////////////////////////////////////////////////

Date::Date()
{
    month = day = dayOfWeek = 0;
    year = 0;
    julian = 0;
}

Date::Date (long j) : julian(j)
{
    julian_to_mdy ();
}

Date::Date ( int y, int m, int d) : year(y), month((unsigned char)m), day((unsigned char)d)
{
    mdy_to_julian ();
}

Date::Date (const char *dat)
{
 	char *tmp, *tmp2;
        int  nlen=strlen(dat);

        tmp = new char[nlen+1];
		//  TML - We need to make a copy of 'dat' because strtok() modifies
		//  the content of its first parameter!!!
		//
        strcpy(tmp, dat);

        //
        //  Possible date string formats are those that are generated by the
        //  Date class itself!  The corresponding possible string lengths are
        //  also listed (with ranges from shortest to longest string for that
        //  format).
        //
        //  MDY:        03/23/1993                      => 6-10,13-17
        //  EUROPEAN:   23 March 1993                   => 13, 20
        //  FULL,ABBR.: Tue, Mar 23, 1993               => 16-17, 23-24
        //  FULL:       Tuesday, March 23, 1993         => 22-23, 29-30
        //
        //  These dates may also have B.C.E. appended at the end, thus we have
        //  the second set of string lengths with 7 more characters!
        //

        month = (unsigned char)atoi(strtok(tmp,"/"));
        day   = (unsigned char)atoi(strtok(NULL,"/"));
        year  = atoi(strtok(NULL," "));

        //
        //  Verify values!
        //
        if ((month < 1) || (month > 12) || (day < 1) ||
            (day > (unsigned char) DaysInMonth()))
        {
            month = day = 0;
            year = 0;
        }

	delete [] tmp;
        mdy_to_julian ();
}


Date::Date (const Date &dt)
{
    month = dt.month;
    day   = dt.day;
    year  = dt.year;
    mdy_to_julian ();
}

//////////////////////////////////////////////////////////////
// Conversion operations
//////////////////////////////////////////////////////////////
Date::operator char *( void )
{
    formatDate();
    return charBuf;
}

//////////////////////////////////////////////////////////////
// Overloading for Date Arithmetic
//////////////////////////////////////////////////////////////

Date & Date::operator + (int i)
{
    julian + (long)i;
    return *this;
}

Date & Date::operator - (int i)
{
    julian - (long)i;
    return *this;
}

long Date::operator - (const Date &dt)
{
    return ( julian - dt.julian );
}

const Date &Date::operator += (int i)
{
	julian += i;
	julian_to_mdy();
	return *this;
}

const Date &Date::operator -= (int i)
{
	julian -= i;
	julian_to_mdy();
	return *this;
}

Date & Date::operator ++()
{
    julian++;
    julian_to_mdy();
    return *this;
}

Date Date::operator ++(int)
{
    Date temp=*this;                    // TML - Necessary to save current
                                        // value of (*this) in order to
    julian++;                           // simulate postfix operation!
    julian_to_mdy();
    return temp;
}

Date &Date::operator --()
{
    julian--;
    julian_to_mdy();
    return *this;
}

Date Date::operator --(int)
{
    Date temp=*this;                    // TML - Necessary to save current
                                        // value of (*this) in order to
    julian--;                           // simulate postfix operation!
    julian_to_mdy();
    return temp;
}

//////////////////////////////////////////////////////////////
// Date comparison
//////////////////////////////////////////////////////////////
int Date::operator <  (const Date &dt)
{
    return ( julian < dt.julian );
}

int Date::operator <= (const Date &dt)
{
    return ( (julian == dt.julian) || (julian < dt.julian) );
}

int Date::operator >  (const Date &dt)
{
    return ( julian > dt.julian );
}

int Date::operator >= (const Date &dt)
{
    return ( (julian == dt.julian) || (julian > dt.julian) );
}

int Date::operator == (const Date &dt)
{
    return ( julian == dt.julian );
}

int Date::operator != (const Date &dt)
{
    return ( julian != dt.julian );
}

////////////////////////////////////////////////////////////////
// Ostream operations
////////////////////////////////////////////////////////////////

ostream &operator << (ostream &os, const Date &dt)
{
	return os << dt.formatDate();
}

//////////////////////////////////////////////////////////////
// Conversion routines
//////////////////////////////////////////////////////////////

void Date::julian_to_wday (void)
{
	dayOfWeek = (unsigned char) ((julian + 2) % 7 + 1);
}

void Date::julian_to_mdy ()
{
	long a,b,c,d,e,z,alpha;
	z = julian+1;

	// dealing with Gregorian calendar reform

	if (z < 2299161L)
		a = z;
	else
	{
		alpha = (long) ((z-1867216.25) / 36524.25);
		a = z + 1 + alpha - alpha/4;
	}

	b = ( a > 1721423 ? a + 1524 : a + 1158 );
	c = (long) ((b - 122.1) / 365.25);
	d = (long) (365.25 * c);
	e = (long) ((b - d) / 30.6001);

	day = (unsigned char)(b - d - (long)(30.6001 * e));
	month = (unsigned char)((e < 13.5) ? e - 1 : e - 13);
        year = (int)((month > 2.5 ) ? (c - 4716) : c - 4715);
	julian_to_wday ();
}

void Date::mdy_to_julian (void)
{
	int a,b=0;
	int work_month=month, work_day=day, work_year=year;

	// correct for negative year

	if (work_year < 0)
		work_year++;

	if (work_month <= 2)
	{
		work_year--;
		work_month +=12;
	}

	// deal with Gregorian calendar

	if (work_year*10000. + work_month*100. + work_day >= 15821015.)
	{
		a = (int)(work_year/100.);
		b = 2 - a + a/4;
	}

	julian = (long) (365.25*work_year) +
			 (long) (30.6001 * (work_month+1))  +  work_day + 1720994L + b;
	julian_to_wday ();
}

////////////////////////////////////////////////////////////////
// Format routine
////////////////////////////////////////////////////////////////
const char *Date::formatDate () const
{
	memset( charBuf, '\0', sizeof(charBuf) );

        if ( (month < 1) || (month > 12) || (dayOfWeek < 1) ||
                 (dayOfWeek > 7) || (day < 1) )
        {
                strcpy(charBuf,"invalid date");

        }
        else
	{
          sprintf( charBuf+strlen(charBuf), "%1d/%1d/%02d", month, day, year);
        }

	return charBuf;
}


///////////////////////////////////////////////////////////////
//  Miscellaneous Routines
///////////////////////////////////////////////////////////////


int Date::isLeapYear( void ) const
{
	return  ( (year >= 1582) ?
		  (year % 4 == 0  &&  year % 100 != 0  ||  year % 400 == 0 ):
		  (year % 4 == 0) );
}



//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
// Version 4.0 Extension to Public Interface - CDP
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

const Date & Date::Today()
{
        struct date sDate;
        getdate(&sDate);

	month = sDate.da_mon;
	day   = sDate.da_day;
	year  = sDate.da_year;

	mdy_to_julian();
	return *this;
}

const Date & Date::Set(int nMonth, int nDay, int nYear)
{
	month = (unsigned char)nMonth;
	year  = nYear < 0 ? 9999 : nYear;
	year  = nYear > 9999 ? 0 : nYear;
    day   = (unsigned char)(nDay < DaysInMonth() ? nDay : DaysInMonth());

	mdy_to_julian();
	return *this;
}

int Date::DaysInMonth()
{
	return GauDays[month-1] + (month==2 && isLeapYear());
}

int Date::Day() const
{
	return day;
}

int Date::NDOW() const
{
	return dayOfWeek;
}

int Date::NMonth() const
{
	return month;
}
int Date::NYear4() const
{
	return year;
}

long  Date::julDate() const
{
        return julian;
}
